# 160 相交链表

给你两个单链表的头节点 headA 和 headB，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null。

图示两个链表在节点 c1 开始相交：

```
A:          a1 → a2
                    ↘
                      c1 → c2 → c3
                    ↗
B:     b1 → b2 → b3
```

题目数据保证整个链式结构中不存在环。

注意，函数返回结果后，链表必须保持其原始结构。

**示例 1：**

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

**示例 2：**

```
输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

**示例 3：**

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null。
```

**提示：**

- listA 中节点数目为 m
- listB 中节点数目为 n
- 1 <= m, n <= 3 \* 10^4
- 1 <= Node.val <= 10^5
- 0 <= skipA <= m
- 0 <= skipB <= n
- 如果 listA 和 listB 没有交点，intersectVal 为 0
- 如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]

**进阶：** 你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？

## 解析

该函数用于查找两个单链表（headA 和 headB）的相交节点。如果两链表相交，返回相交的节点；如果不相交，返回 null。

### 算法思路

**双指针遍历：**

1. 初始化两个指针 p 和 q，分别指向链表 headA 和 headB 的头节点。
2. 同步移动指针：
   - p 从 headA 开始遍历，到达尾部后跳转到 headB 继续遍历；
   - q 从 headB 开始遍历，到达尾部后跳转到 headA 继续遍历。
3. 当 p 和 q 相遇时，相遇点即为相交节点（或 null）。

**数学原理：**
设链表 A 的非公共部分长度为 a，链表 B 的非公共部分长度为 b，公共部分长度为 c。

- 指针 p 的路径：a + c + b
- 指针 q 的路径：b + c + a

两指针路径长度相同，循环结束时，如果两条链表相交，那么此时 p 和 q 都在相交的起始节点处，返回 p；如果两条链表不相交，那么 p 和 q 都走到空节点，所以也可以返回 p，即空节点。因此必然在相交点相遇（或同时到达尾部 null）。


### 代码实现

```javascript
const getIntersectionNode = (headA, headB) => {
  let p = headA,
    q = headB; // 初始化指针
  while (p !== q) {
    // 当两指针未相遇时循环
    p = p ? p.next : headB; // p 移动到下一个节点，若到尾部则切换到 headB
    q = q ? q.next : headA; // q 移动到下一个节点，若到尾部则切换到 headA
  }
  return p; // 返回相遇点（可能是节点或 null）
};
```

**代码解析：**

- 使用两个指针 p 和 q 分别遍历两个链表
- 当指针到达链表末尾时，跳转到另一个链表的头部继续遍历
- 通过这种方式，两个指针最终会在相交点相遇，或者同时到达 null（表示不相交）
- 时间复杂度：O(m + n)，空间复杂度：O(1)
