# 141 环形链表

给你一个链表的头节点 head，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 true。否则，返回 false。

**示例 1：**

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

**提示：**
- 链表中节点的数目范围是 [0, 10^4]
- -10^5 <= Node.val <= 10^5
- pos 为 -1 或者链表中的一个有效索引

**进阶：** 你能用 O(1)（即，常量）内存解决此问题吗？

## 解析

### 算法思路：快慢指针法（Floyd 判圈算法）

**核心思想：**
使用两个指针，一个快指针和一个慢指针。快指针每次移动两步，慢指针每次移动一步。如果链表中存在环，快指针最终会追上慢指针；如果不存在环，快指针会先到达链表末尾。

**数学原理：**
- 如果链表中有环，快指针和慢指针都会进入环
- 在环中，快指针每次比慢指针多走一步
- 经过若干次移动后，快指针会追上慢指针（套圈）
- 如果链表无环，快指针会先到达 null

**为什么快指针移动两步？**
- 移动两步可以保证在有限时间内相遇
- 如果移动三步或更多，可能会错过慢指针
- 移动两步是最优的选择

### 代码实现

```javascript
/**
 * @param {ListNode} head
 * @return {boolean}
 * 快慢指针
 */
var hasCycle = function (head) {
    // 乌龟和兔子同时从起点出发
    let slow = head, fast = head;
    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
        // 兔子追上乌龟（套圈），说明有环
        if (fast === slow) {
            return true;
        }
    }
    return false; // 访问到了链表末尾，无环
};
```

### 详细代码解析

**1. 初始化阶段：**
```javascript
let slow = head, fast = head;
```
- 将慢指针（乌龟）和快指针（兔子）都初始化为指向链表的头节点
- 两个指针同时从起点出发

**2. 循环条件：**
```javascript
while (fast && fast.next)
```
- `fast`：确保快指针没有到达链表末尾
- `fast.next`：确保快指针可以安全地移动两步
- 如果快指针到达 null，说明链表无环

**3. 指针移动：**
```javascript
slow = slow.next;      // 乌龟移动 1 步
fast = fast.next.next; // 兔子移动 2 步
```
- 慢指针每次只移动一个节点
- 快指针每次移动两个节点
- 快指针的速度是慢指针的 2 倍

**4. 相遇检测：**
```javascript
if (fast === slow) {
    return true;
}
```
- 检查快指针是否追上了慢指针
- 如果相遇，说明链表中存在环
- 立即返回 true


### 算法复杂度分析

**时间复杂度：** O(n)
- 最坏情况下，快指针需要遍历整个链表
- 如果有环，快指针会在环内追上慢指针
- 总的时间复杂度为 O(n)

**空间复杂度：** O(1)
- 只使用了两个指针变量
- 不依赖链表长度，空间复杂度为常数

### 边界情况处理

**1. 空链表：**
- 初始时 `head` 为 null
- 循环条件不满足，直接返回 false

**2. 单节点链表：**
- 如果单节点指向自己，形成自环
- 第一次循环后 `fast` 和 `slow` 都指向该节点
- 检测到相遇，返回 true

**3. 双节点链表：**
- 如果两个节点互相指向，形成环
- 快指针会追上慢指针
- 检测到相遇，返回 true

### 进阶思考

**为什么快指针移动两步是最优的？**
- 移动两步可以保证在有限时间内相遇
- 如果移动三步，可能会跳过慢指针
- 移动两步是保证相遇的最小步数

**如何找到环的入口点？**
- 当快慢指针相遇后，将慢指针重置到头节点
- 两个指针都以相同速度移动
- 再次相遇的点就是环的入口

**如何计算环的长度？**
- 在快慢指针相遇后，让慢指针继续移动
- 记录移动步数，直到再次相遇
- 步数就是环的长度
