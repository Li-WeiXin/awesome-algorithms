# 142 环形链表 II

给定一个链表的头节点 head，返回链表开始入环的第一个节点。如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。

注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改链表。

**示例 1：**

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

**提示：**
- 链表中节点的数目范围在范围 [0, 10^4] 内
- -10^5 <= Node.val <= 10^5
- pos 的值为 -1 或者链表中的一个有效索引

**进阶：** 你是否可以使用 O(1) 空间解决此题？

## 解析

### 算法思路：快慢指针法（Floyd 判圈算法）

**核心思想：**
1. 使用快慢指针检测环的存在
2. 当快慢指针相遇后，重新定位环的入口点
3. 利用数学原理找到环的入口

**数学原理：**
- 设链表头到环入口的距离为 a
- 环入口到相遇点的距离为 b
- 相遇点到环入口的距离为 c
- 环的长度为 L = b + c

**推导过程：**
- 快指针走的距离：a + b + nL（n 为快指针在环内走的圈数）
- 慢指针走的距离：a + b
- 由于快指针速度是慢指针的 2 倍：a + b + nL = 2(a + b)
- 化简得：nL = a + b
- 进一步推导：a = nL - b = (n-1)L + c

**结论：**
- 从链表头走 a 步到达环入口
- 从相遇点走 c 步也到达环入口
- 因此让一个指针从链表头开始，另一个从相遇点开始，同速移动，相遇点就是环入口

### 代码实现

```javascript
var detectCycle = function (head) {
    // 初始化快慢指针，都指向链表头部
    let slow = head, fast = head;
    
    // 快指针遍历链表（需确保fast和fast.next存在）
    while (fast && fast.next) {
        slow = slow.next;          // 慢指针移动1步
        fast = fast.next.next;     // 快指针移动2步
        
        // 当快慢指针相遇时，说明存在环
        if (fast === slow) {
            // 关键步骤：重新定位环入口
            while (slow !== head) {
                // 慢指针（在环内）和头指针同步移动
                slow = slow.next;   // 慢指针从相遇点继续移动
                head = head.next;   // 头指针从链表头移动
            }
            // 两指针相遇处即为环的入口节点
            return slow;
        }
    }
    // 遍历完成无环，返回null
    return null;
};
```

### 详细代码解析

**第一阶段：检测环的存在**
```javascript
let slow = head, fast = head;
while (fast && fast.next) {
    slow = slow.next;          // 慢指针移动1步
    fast = fast.next.next;     // 快指针移动2步
    
    if (fast === slow) {
        // 检测到环，进入第二阶段
    }
}
```
- 使用快慢指针检测环的存在
- 快指针移动两步，慢指针移动一步
- 当快慢指针相遇时，说明链表中存在环

**第二阶段：定位环入口**
```javascript
while (slow !== head) {
    slow = slow.next;   // 慢指针从相遇点继续移动
    head = head.next;   // 头指针从链表头移动
}
return slow;
```
- 当快慢指针相遇后，慢指针保持在相遇点
- 头指针从头节点开始移动
- 两个指针同速移动，相遇点就是环的入口

**为什么这样能找到环入口？**
- 根据数学推导：a = (n-1)L + c
- 从链表头走 a 步 = 从相遇点走 c 步
- 因此两个指针同速移动，会在环入口相遇

### 算法复杂度分析

**时间复杂度：** O(n)
- 第一阶段：快慢指针相遇，最多遍历整个链表
- 第二阶段：定位环入口，最多遍历环的长度
- 总时间复杂度：O(n)

**空间复杂度：** O(1)
- 只使用了两个指针变量
- 不依赖链表长度，空间复杂度为常数

### 边界情况处理

**1. 空链表：**
- 初始时 `head` 为 null
- 循环条件不满足，直接返回 null

**2. 单节点链表：**
- 如果单节点指向自己，形成自环
- 第一次循环后快慢指针相遇
- 进入第二阶段，找到环入口（即头节点）

**3. 无环链表：**
- 快指针会先到达链表末尾
- 循环正常结束，返回 null

**4. 环在链表开头：**
- 快慢指针在头节点相遇
- 第二阶段循环不会执行
- 直接返回头节点

### 算法优化思考

**为什么快指针移动两步？**
- 移动两步可以保证在有限时间内相遇
- 如果移动三步或更多，可能会错过慢指针
- 移动两步是最优的选择

**如何计算环的长度？**
- 在快慢指针相遇后，让慢指针继续移动
- 记录移动步数，直到再次相遇
- 步数就是环的长度

**如何判断环的长度？**
- 环的长度 = 快指针走的距离 - 慢指针走的距离
- 在相遇时：快指针走了 2(a+b)，慢指针走了 a+b
- 环的长度 = 2(a+b) - (a+b) = a+b

### 与其他题目的联系

**与 141 环形链表的区别：**
- 141 题只需要判断是否有环
- 142 题需要找到环的入口点
- 142 题在 141 题的基础上增加了定位环入口的步骤

**与 876 链表的中间结点的联系：**
- 都使用了快慢指针技巧
- 876 题利用速度关系找中点
- 142 题利用速度关系找环入口
