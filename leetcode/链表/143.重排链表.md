# 143 重排链表

给定一个单链表 L 的头节点 head，单链表 L 表示为：

```
L0 → L1 → … → Ln - 1 → Ln
```

请将其重新排列为：

```
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

**示例 1：**

```
输入：head = [1,2,3,4]
输出：[1,4,2,3]
```

**示例 2：**

```
输入：head = [1,2,3,4,5]
输出：[1,5,2,4,3]
```

**提示：**
- 链表的长度范围为 [1, 5 * 10^4]
- 1 <= node.val <= 1000

## 解析

### 算法思路：三步法

**核心思想：**
将重排链表问题分解为三个步骤：
1. 找到链表的中间节点
2. 反转后半部分链表
3. 交替合并前半部分和反转后的后半部分

**算法步骤：**
1. **找中点**：使用快慢指针找到链表的中间节点
2. **反转后半部分**：将后半部分链表反转
3. **交替合并**：将前半部分和反转后的后半部分交替合并

### 代码实现

```javascript
// 876. 链表的中间结点（快慢指针法）
function middleNode(head) {
    // 初始化快慢指针，均指向链表头部
    let slow = head, fast = head;
    // 快指针每次移动两步，慢指针每次移动一步
    while (fast !== null && fast.next !== null) {
        slow = slow.next;       // 慢指针移动一步
        fast = fast.next.next;  // 快指针移动两步
    }
    // 当快指针到达链表末尾时，慢指针指向中间节点
    return slow;
}

// 206. 反转链表（迭代法）
function reverseList(head) {
    // 初始化前驱节点为 null，当前节点指向链表头
    let pre = null, cur = head;
    while (cur !== null) {
        const nxt = cur.next;  // 保存当前节点的下一个节点
        cur.next = pre;         // 反转指针：当前节点指向前驱节点
        pre = cur;              // 前驱节点后移
        cur = nxt;              // 当前节点后移
    }
    // 最后 pre 成为新链表的头节点
    return pre;
}

var reorderList = function (head) {
    // 1. 找到链表中点（后半部分的起点）
    const mid = middleNode(head);
    
    // 2. 反转后半部分链表
    let head2 = reverseList(mid);
    
    // 3. 交替合并两个链表
    while (head2.next) {  // 当后半部分还有节点时
        const nxt = head.next;   // 保存前半部分下一个节点
        const nxt2 = head2.next; // 保存后半部分下一个节点
        
        head.next = head2;       // 前半部分当前节点指向后半部分当前节点
        head2.next = nxt;        // 后半部分当前节点指向前半部分下一个节点
        
        head = nxt;              // 前半部分指针后移
        head2 = nxt2;            // 后半部分指针后移
    }
};
```

### 详细代码解析

**第一步：找到链表中点**
```javascript
const mid = middleNode(head);
```
- 使用快慢指针法找到链表的中间节点
- 快指针移动两步，慢指针移动一步
- 当快指针到达末尾时，慢指针指向中间节点

**第二步：反转后半部分**
```javascript
let head2 = reverseList(mid);
```
- 将后半部分链表反转
- 使用迭代法反转链表
- 返回反转后的头节点

**第三步：交替合并**
```javascript
while (head2.next) {
    const nxt = head.next;   // 保存前半部分下一个节点
    const nxt2 = head2.next; // 保存后半部分下一个节点
    
    head.next = head2;       // 前半部分当前节点指向后半部分当前节点
    head2.next = nxt;        // 后半部分当前节点指向前半部分下一个节点
    
    head = nxt;              // 前半部分指针后移
    head2 = nxt2;            // 后半部分指针后移
}
```

**合并过程详解：**
1. **保存后继节点**：防止断链
2. **建立连接**：前半部分节点指向后半部分节点
3. **建立反向连接**：后半部分节点指向前半部分的下一个节点
4. **指针后移**：移动到下一个待处理的节点

### 算法复杂度分析

**时间复杂度：** O(n)
- 找中点：O(n/2) ≈ O(n)
- 反转后半部分：O(n/2) ≈ O(n)
- 交替合并：O(n/2) ≈ O(n)
- 总时间复杂度：O(n)

**空间复杂度：** O(1)
- 只使用了常数个指针变量
- 不依赖链表长度

### 边界情况处理

**1. 单节点链表：**
- 中间节点就是头节点
- 后半部分为空，合并循环不会执行
- 结果保持不变

**2. 双节点链表：**
- 中间节点是第二个节点
- 后半部分只有一个节点
- 合并后形成交叉连接

**3. 奇数长度链表：**
- 中间节点是正中间的节点
- 后半部分比前半部分少一个节点
- 合并时后半部分先结束

**4. 偶数长度链表：**
- 中间节点是后半部分的第一个节点
- 前后两部分长度相等
- 合并时同时结束

### 算法优化思考

**为什么使用快慢指针找中点？**
- 只需要一次遍历就能找到中点
- 避免了先计算长度再找中点的两次遍历

**为什么反转后半部分而不是前半部分？**
- 反转后半部分可以保持前半部分的顺序
- 便于后续的交替合并操作

**合并循环的条件为什么是 `head2.next`？**
- 确保后半部分还有节点需要合并
- 避免处理最后一个节点时的边界情况
